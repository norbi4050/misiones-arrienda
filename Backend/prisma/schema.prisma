generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Property {
  id          String   @id @default(cuid())
  title       String
  description String
  price       Float
  oldPrice    Float?
  bedrooms    Int
  bathrooms   Int
  garages     Int      @default(0)
  area        Float
  lotArea     Float?
  address     String
  city        String
  province    String
  postalCode  String
  latitude    Float?
  longitude   Float?
  propertyType String  // APARTMENT, HOUSE, COMMERCIAL, LAND, OFFICE, WAREHOUSE, PH, STUDIO
  status      String   @default("AVAILABLE") // AVAILABLE, RENTED, SOLD, MAINTENANCE, RESERVED
  images      String   // JSON string of array
  virtualTourUrl String?
  amenities   String   // JSON string of array
  features    String   // JSON string of array
  yearBuilt   Int?
  floor       Int?
  totalFloors Int?
  featured    Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  agent       Agent    @relation(fields: [agentId], references: [id])
  agentId     String
  
  inquiries   Inquiry[]
  userInquiries UserInquiry[]
  favorites   Favorite[]
  rentalHistory RentalHistory[]
  
  @@index([city, province])
  @@index([price])
  @@index([propertyType])
  @@index([status])
  @@index([featured])
}

model Agent {
  id          String   @id @default(cuid())
  name        String
  email       String   @unique
  phone       String
  avatar      String?
  bio         String?
  license     String   @unique
  rating      Float    @default(0)
  reviewCount Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  properties  Property[]
}

model Inquiry {
  id        String   @id @default(cuid())
  name      String
  email     String
  phone     String
  message   String
  type      String   // GENERAL, VISIT, FINANCING, OFFER
  visitDate DateTime?
  createdAt DateTime @default(now())
  
  property  Property @relation(fields: [propertyId], references: [id])
  propertyId String
}

model User {
  id          String   @id @default(cuid())
  name        String
  email       String   @unique
  phone       String
  avatar      String?
  bio         String?
  occupation  String?
  age         Int?
  verified    Boolean  @default(false)
  rating      Float    @default(0)
  reviewCount Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relaciones
  favorites   Favorite[]
  inquiries   UserInquiry[]
  reviewsGiven UserReview[] @relation("ReviewGiver")
  reviewsReceived UserReview[] @relation("ReviewReceiver")
  rentalHistory RentalHistory[]
}

model UserReview {
  id          String   @id @default(cuid())
  rating      Int      // 1-5 estrellas
  comment     String
  category    String   // TENANT, LANDLORD
  verified    Boolean  @default(false) // Si el review es de un alquiler verificado
  createdAt   DateTime @default(now())
  
  // Relaciones
  reviewer    User     @relation("ReviewGiver", fields: [reviewerId], references: [id])
  reviewerId  String
  reviewed    User     @relation("ReviewReceiver", fields: [reviewedId], references: [id])
  reviewedId  String
  
  // Opcional: relacionar con el alquiler espec√≠fico
  rental      RentalHistory? @relation(fields: [rentalId], references: [id])
  rentalId    String?
}

model RentalHistory {
  id          String   @id @default(cuid())
  startDate   DateTime
  endDate     DateTime?
  monthlyRent Float
  deposit     Float?
  status      String   @default("ACTIVE") // ACTIVE, COMPLETED, TERMINATED
  createdAt   DateTime @default(now())
  
  // Relaciones
  tenant      User     @relation(fields: [tenantId], references: [id])
  tenantId    String
  property    Property @relation(fields: [propertyId], references: [id])
  propertyId  String
  
  // Reviews relacionados a este alquiler
  reviews     UserReview[]
}

model UserInquiry {
  id        String   @id @default(cuid())
  message   String
  type      String   // GENERAL, VISIT, FINANCING, OFFER
  visitDate DateTime?
  status    String   @default("PENDING") // PENDING, RESPONDED, CLOSED
  createdAt DateTime @default(now())
  
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  property  Property @relation(fields: [propertyId], references: [id])
  propertyId String
}

model Favorite {
  id         String   @id @default(cuid())
  user       User     @relation(fields: [userId], references: [id])
  userId     String
  property   Property @relation(fields: [propertyId], references: [id])
  propertyId String
  createdAt  DateTime @default(now())
  
  @@unique([userId, propertyId])
}
